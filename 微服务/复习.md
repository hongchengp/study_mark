# 微服务



## 引入原因

如果是单体架构

虽然 controller层解耦了，

但是，service没有，经常有 Aservice (下面将service省略) 调用 B，service层紧耦合了，如果B改变了 ，可能A也要跟着改变

不好，if 规模非常大，寄。怎么办，用模块化是是思想， **模块 对外暴露的 interface** ，是很**难变化**的。

每个**模块** 都是**独立**的，只通过 网络 访问interface来交互。

模块 就是 微服务 （独立运行，开发，测试，so，可以用 docker来管理）

微服务，就是将 大的单体项目，拆分成 独立 小的模块

分布式的一种，垂直拆分





## 构成



### 注册与发现中心

微服务都是 通过网络 交互，so 要知道 ip + port。微服务ip or port 改变，or 微服务数量变化，那**所有和它交互的 节点都要改变**。

不好，节点 和 节点耦合了。

这种 **点到点 的交互不好**，节点和节点紧耦合。

用 中介者，注册与发现中心。



解决了 **节点与节点通信**的问题，实现了 **节点 ip + port，or 节点数 可以改变**。

**节点间通信，通过 它，完成用服务名来交互**



#### 关键词

**节点与节点 通信**

**节点改变**（ip + port or 节点数）



### 网关



#### 引入原因

nginx 是 客户端统一的入口，为什么还要它呢

http请求 (域名)-> dns -> nginx -> 后端服务器

nginx 反向代理 + 负载均衡，but它调用 后端服务器 的 ip + port 是写死了的

节点if 改变，寄

so，我们应该加一层不会改变的 **后端统一入口** 给 nginx

而 它通过 注册与发现中心，可以应对节点的改变



#### 解决问题

**统一入口**

流量的统一管理

路由 （url 到 微服务api的映射）

身份认证 （jwt，不用重复搞）

限流 （api网关）

熔断 

权限



#### 关键词

统一入口





## 微服务保护

应该 是api层面的

可以用 api网关



### 请求限流

防止一种请求太多，别的请求没有

多的，直接拒绝



### 线程隔离

防止雪崩，因为如果一种请求一直占用资源，别的请求就很难用到线程池

而且调用它的，也会因为它，一直阻塞（熔断也可以处理这个）



### 熔断

就是如果微服务调用老是失败，就直接调用，而是执行 errorfallback





