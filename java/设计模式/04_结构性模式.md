# 代理模式

是对功能的增强

它会有成员，指向要代理的类

代理类的接口和类是一样的，所以通过springboot，可以透明的使用

aop就是使用的这种思想

就是将函数传入，他们可以在这个函数前后进行编码，对功能增强

**回调函数**

是迪米特法则的运用，加入中间层，这样就可以只改变代理类就可以改变功能，使客户端和底层类解耦了



## 静态代理

是在编译期就已经编写好的



## 动态代理

由jvm在运行时生成的

怎么生成的，应该时通过对类的字节码

这样就可以不用硬编码的编写

jdk使用的组合，所以如果是接口or虚类就不可以了

另一个用的是继承，所以接口和类都可以



# 适配器模式

就是改造接口

比如三个参数的改为两个参数的，与bind很像，让接口兼容

还是用继承，实现来完成适配器的

用组合比继承要更好





# 装饰者模式

它是防止产生大量的子类



它用的继承 + 组合

还可以装饰器间的组合

装饰器有具体类的引用

复合原则，组合是优于继承的



# 桥接模式

它是有两个变化维度时

用组合

分为两个类

这样两个类就可以独立的变化，解耦了

如果都是一个类的话，有一个维度变化那么就会增加很多子类

让一个类，有另一个类的引用



# 外观模式

它是迪米特法则的经典应用

它隐藏了子系统的复杂性，客户端只需要调用外观类的接口就可以了

比如电脑关机，我们只用点关机就可以，不需要了解内部的cpu，内存等等

它解耦了客户端和子系统

接口一般是不会变的，子系统改变，只用改变外观模式和子系统，客户端不用变



感觉java框架就是外观模式的使用

怎么用，当客户端用到很多子系统关联时

系统调用也是



# 享元模式

就是将共同的部分共享（内部状态）

但是如果要不同的部分怎么办

原本它他们是类的参数

我们可以将它作为参数传入



那我们要改变怎么办，copyOnWrite

只生成一例，单列模式 用双重锁 

有序性 用volicate

