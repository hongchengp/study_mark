# Netty基础

non-blocking io 非阻塞 IO（就是tryLock的思想）



## 三大组件



### Channel & Buffer

Channel可以看为fd

Buffer就是将fd中数据读出，写入的缓冲区

fd中已经有缓冲区了，为什么还有buffer呢，直接用fd中的不就好了

我们会对发送的内容进行一系列操作，而fd的缓冲区是内核态的，用户不应该操作



### Selector

可以看做epoll

用来事件监听的

它就是事件驱动（epoll，怎么监听的，我们不管，分层的思想）

每个eventLoop都只有一个selector

selector管理一些fd

fd只能被一个selector管理，这就意味着fd只会被一个线程管理

这样就没有并发问题，比如同时写，同时读



## TCP的面向字节流

它是什么意思呢

fd.read(buf)->int

就是它return的是读出的字节数，不一定完全读出（可能是因为buf大小不够）



fd.write(buf) -> int 

return的是它写入fd缓冲区的字节数（不一定会完全写入，可能是fd的缓冲区不够）

这个就会带来，粘包和半包的问题

udp为什么不会，因为它会将整个报文发送来（会记录报文的边界，用数据头，记录长度）

我们也可以用数据头来记录长度

**TCP只解决有连接，可靠传输**

**粘包和半包由上层解决**



## ByteBuffer



它封装了读写操作（用读写指针来实现）

它既可以读，也可以写（但是要模式转换）

为什么不可以同时读写呢，反正不会被影响（ToDo 我也不理解，和阻塞任务队列一样）

好吧，那是因为对于网络编程来说，写入缓冲区，因为是从fd中读出的，应该一次性，不应该在写的时候读



### 零拷贝

java是不能直接和操作系统交互的

fd缓冲区读出的，要在c++用一个缓冲区

它就多了一次拷贝

那怎么办，用直接内存，但是呢，它不会经过垃圾回收

用的引用计数（智能指针）



它还是有拷贝，它只是减少拷贝



### 分开读 & 一起写

读如果buf不够大，就会进行数据拷贝

怎么样不用数据拷贝，还可以读完呢

用读个数组

同样的写也可以





## 协程

我们看线程

sleep

线程是会阻塞的

但是对于协程来说，用它给的sleep，是不会阻塞线程的，它会由调用器来执行别的函数

在java中函数就是（Runnable）