# 阻塞

socket中的accept和read都是阻塞的

效率太低了



# 非阻塞

它的思想和tryLock很像

成功了true 失败 false

accept 成功socket 失败 null

read 成功 字节数 失败 0

但是呢？read 和 accept都是有消耗的

浪费cpu



用io多路复用（有点像pull 和 push的思想，它不主动，我主动监听）

是，事件监听机制



# 异步



就是自己不做，给别的线程做

很像消息队列

那怎么知道完成了呢（别的线程）

本质是线程间的通信（就可以用信号量解决，底层是这个）



## future



它可以接受线程中函数return的结果

用到它的get函数，还是阻塞的（底层应该是用条件变量实现的）

用着lazy的思想



## promise



它很像go里面的channel

还是用的条件变量和锁（因为多线程共享）

不用等到线程执行完，

只要线程往promise加入数据就可以

空的时候不可以读（还是阻塞）

满的时候不可以写（阻塞）

