# 可重入锁

通过记录线程id，如果是上锁的线程，就让他获得锁

引用计数加一



# 共享锁

就是可以被多个线程使用

比如读锁

也是用引用计数，但是可以不用记录线程id了



# 自旋锁

就是在第一次尝试获得锁的时候，多尝试几次

它是非公平锁

但是它的效率很高

因为第一次尝试，该线程一定是获得cpu的，如果让它获得锁，就不用线程切换



# trylock

它是防止一直等待，如果比较久没有获得锁，就放弃

那我们怎么知道有没有得到锁呢

它的return值

true为获得，false为没有获得、



# 条件变量

它的名字告诉我们，它是要符合某些条件

它是主动放弃锁，因为它等待的资源还没到位

用它之前要先获得锁
为什么一定要获得锁，不要锁可不可以

也可以，那就是阻塞操作，比如读取文件

要锁的情况是因为，它要别的线程产生资源

那个资源就是共享变量，它是要上锁的

用wait 和 notify



## 虚假唤醒

如果有多个等待线程

用了notifyAll（），但是我们要的资源还没就绪

那我们还是要继续等待

所以要

while（!flag） {

​	conn.wait();

}

只有资源就绪才会跳出循环



# 锁的原理



## 原子性的原理

通过aqs，就是同步器（cas）+ volatile

保证只有一个线程可以获得锁和可见性



## 自旋锁

第一次尝试获得锁时，多尝试几次



## 等待队列

没有获得锁的会将线程信息（主要是id + 要等到的锁）封装成node，加入阻塞队列

它是双向的

为什么，因为node的唤醒，是通过它的前继节点唤醒的，那怎么前继node怎么知道要唤醒呢

只有加入时后继节点通知前继节点，所以为了找到前继，就是双向

就是要让后继节点通知前继要唤醒我

如果走到这步，锁的获得是公平的



## 阻塞队列

就是wait的

它是单向的，通过park阻塞，unpark唤醒的

如果被唤醒它会进入等待队列

其实等待队列的唤醒也是用unpark（底层应该是系统调用）



## 读写锁

就是status要改变一下

底层和锁是一样的

