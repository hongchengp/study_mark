为什么要责任链呢

责任链模式的核心是一个链式结构，链中每个节点代表一个处理者对象，请求先经过第一个节点处理，如果该节点能够处理请求，则直接返回处理结果；否则，请求继续往下一个节点传递，直到找到能够处理该请求的节点为止。整个过程类似于流水线上的多个工作站，每个工作站负责一项工作，如果自己处理不了，就将工作交给下一个工作站，直到整个工作完成。

我们想一下如果要检查参数是否合法，但是参数非常多，那么写在一个函数里面将会非常臃肿，

而且对于通用的判断难以复用



解决，责任链，每个只负责处理自己的，处理好后再给下一个函数

那么当又要加入一个检验怎么办，会违反开闭原则啊



当当当，springboot登场了，可以通过springboot 将责任链模式加载放入上下文，

这样就可以解耦了，因为呢springBoot是通过注解（就是配置）来加入上下文的，是解耦的

我们实现时，还可以加入排序字段，来调整责任链中顺序，也可以加入mark（），来得到不同的责任链。





# 实现

![image-20240422170229374](../../../AppData/Roaming/Typora/typora-user-images/image-20240422170229374.png)

继承Ordered是为了可以排序



![image-20240422170332140](../../../AppData/Roaming/Typora/typora-user-images/image-20240422170332140.png)

![image-20240422170406947](../../../AppData/Roaming/Typora/typora-user-images/image-20240422170406947.png)

![image-20240422170427561](../../../AppData/Roaming/Typora/typora-user-images/image-20240422170427561.png)

![image-20240422170444862](../../../AppData/Roaming/Typora/typora-user-images/image-20240422170444862.png)



这个是我们直接实现的责任链，可以直接注入使用。

责任链模式，有很多使用，比如过滤器，拦截器。当然这两个是通过aop实现的，也是为了解耦。

shardingsphere也有点像aop，直接再最外面加了一层，不会破环本来的代码。