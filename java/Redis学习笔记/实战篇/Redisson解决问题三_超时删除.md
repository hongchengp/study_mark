获取锁成功之后----超时过期问题:[看门狗机制]
一.说明
一定有个概念,只有获取锁成功了才会有leasetime的事情.
1.leaseTime: 释放锁的时长...
  如果传入-1,会给个默认的锁超时释放时间30s...
2.我必须确保锁是业务执行结束释放的,而不是阻塞之后自己超时释放...
  首先尝试获取锁时传入leaseTime,或者不传入默认为30s.
获取锁成功且当leaseTime为-1时(默认)[-1才会走看门狗的逻辑]:
	如果获取锁成功,会有一个自动更新过期时间的一个函数.
	Redisson有一个自动续约更新的静态变量map,专门用于存储Redisson的不同锁的实例.
	就是Redisson创建的各个锁的实例都会被放到Redisson是静态变量map中,以锁的名字为key,
	每个锁创建的对应的Entry为value存入.达到的效果就是只要是同一个锁实例,不管来几次
	将来拿到的永远是同一个entry.
	每一个锁实例都有自己对应的一个entry,entry中存放了threadId和定时任务.
	这个定时任务就是每隔10s会递归的调用自己,在单层递归的逻辑中完成对于锁过期时间的刷新...保证锁永不过期.
	知道当这把锁被unlock()成功之后,会从map中剔除锁实例,并清除锁对应的entry中存储的threadId和定时任务...

	如果是第一次获取到锁,会执行一个更新有效期的函数,这个函数里面实现了一个定时任务,
	在 30 / 3s 后会执行任务,任务又是递归调用自己,总结就是递归调用自己一直在刷新锁的有效期,所以,永不过期!

照这样锁什么时候释放???在unlock锁成功释放之后,有一个回调函数,会取消这个定时的更新任务.
获取锁成功且当leasetime不为-1时(自己传值)
	如果获取锁成功后，leasetime传入的不是-1，而是一个具体的时间，比如20s，那么Redisson会在20s后自动释放该锁，即使业务阻塞时间超过20s，
	锁也会被释放。在这种情况下，Redisson并不会启动开门狗机制，因为它知道锁的过期时间是20s，所以不需要再去刷新锁的过期时间。如果你希
	望锁一直有效，可以将leasetime设置为-1，这样Redisson会开启开门狗机制，确保锁一直有效，直到被释放。



所以只有传入-1时才会有看门狗机制，它可以保证当任务执行时，锁不会释放。不像我们的都会有锁的TTL时间，可能任务还没完成锁就释放了。

