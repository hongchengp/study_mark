自定义分布式锁有哪些问题.Redisson又是如何解决的??
- 不可重入
- 不可重试
- 超时释放
- 主从一致性
===============================================================================
1.自定义的分布式锁不可以实现锁重入
- 因为同一个线程setnx都是一样的,是不允许的.

2.参考ReentryLock实现锁重入的原理

每次相同的线程又一次来获取锁就对state变量值进行++操作... 

原理：引用计数 当减为0时 才释放锁



3.分布式锁Redisson和自定义分布式锁的一些区别:
- 底层是hash结构,因为value部分不仅仅要存储"获取到锁的线程标识",还要存储"当前线程重入的次数"(支持锁重入的原理).
  所以string类型没法满足,底层是hash类型来存储...
	
- 自定锁string是通过setnx保证互斥性,但hash结构没有这种api,所以保持互斥性只能先判断锁是否存在,然后再互斥/获取到锁..
  上来判断锁不存在,说明获取到锁了,否则说明已经有人获取到锁了!

![image-20240306130753766](../../../AppData/Roaming/Typora/typora-user-images/image-20240306130753766.png)

二. 分布式锁的原理
redisson	-->		hash	-->		lua脚本(lua脚本是原子性的,不需要再加锁)
注意: [获取锁]和[释放锁]的这些步骤都是通过lua脚本实现的原子性!!!
	
获取锁的lua:											释放锁的lua:



![image-20240306130836356](../../../AppData/Roaming/Typora/typora-user-images/image-20240306130836356.png)		



![image-20240306130933734](../../../AppData/Roaming/Typora/typora-user-images/image-20240306130933734.png)



![image-20240306130942998](../../../AppData/Roaming/Typora/typora-user-images/image-20240306130942998.png)

延伸:
在释放锁的lua脚本中,释放完锁之后还会pub发布一个消息,告诉别的尝试获取锁的线程说释放成功锁了...