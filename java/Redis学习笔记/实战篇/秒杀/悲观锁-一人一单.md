

一人一单逻辑流程

 * ```java
     /**
     
      * 单机版本: 秒杀逻辑
     
      * @param voucherId 秒杀购买的优惠券Id
     
     * @return 返回结果 
        	悲观锁解决一人一单问题.因为防止别的线程重复创建订单,这是插入数据操作,乐观锁
        	只能判断并发场景下的数据更新问题,不能乐观锁思想防止插入的线程安全问题,所以需
        	要悲观锁来控制,且注意锁的粒度大小
        	要在查询前就上锁
        	 */
        	@Override
        	public Result secondBuyDanJi(Long voucherId) {
        	/**
        
        	 * 单机版本: 秒杀下单的业务
        		*/
        		// 当前用户信息
        		UserDTO user = UserHolder.getUser();
        		//TODO 1.判断抢购时间和库存是否合法
         		synchronized (user.getId().toString().intern()) {  
          		//TODO 2.查询订单并判断当前商品id和用户id的该订单是否已经存在(实现一人一单)
          
          		//TODO 3.扣减库存(乐观锁解决超卖问题)
          
          		//TODO 4.创建新订单
          
          	}
          	return null;
          	}
     ```



分布式锁问题：

1. 超时误删

	超时时删除别人的锁；可以通过判断是不是自己的锁。

2. 判断 删除没有原子性误删

	判断后，阻塞导致超时，误删别人的锁；通过lua脚本，原子操作。

3. 不可重入

	使用引用计数（就是智能指针）

4. 不可重试

	发布订阅

5. 超时删除

	看门狗机制，如果是还未完成，那就刷新过期时间，如果挂了，就超时后释放。