## 1.初见JVM

### 1.1 什么是JVM

java virtual machine

跨平台 & 自动内存管理

**跨平台就是因为，jvm指令一样，但是不同的平台有不同的 jvm，可以解释成对应的 机器码**

但是会慢

### 1.2 JVM功能

#### 1.2.1 解释与运行

.java 编译成 .class （字节码文件），它都是**jvm指令，linux是看不懂的，他要通过jvm解释成相对应的二进制指令**

（**.class文件中的 常量池，都是符号引用，不是逻辑地址**）

**c文件，都是在 链接阶段，将符号引用解析为 逻辑地址的，之后在 装入阶段，将逻辑地址和真实的物理地址对应**

**装入就是 将磁盘中的 文件 装入到 内存**

**java的链接，是在装入到内存后进行的，它会将符号引用，解析为逻辑地址（连接阶段中的 解析）**

逻辑地址，jvm有自己的机制将它和 物理地址对应

操作系统，有页表，将逻辑地址 和 物理地址对应（这个是内存的虚拟性）



#### 1.2.2 内存管理

主要是 堆（new 的对象 和 字符串常量池） 和 方法区 （class元信息 和 运行时常量池（将符号引用解析为逻辑地址））

堆中分配的对象，还会进行垃圾回收



#### 1.2.3 即时编译

**将热点代码，直接编译成 机器指令，不用重复的解释（jvm指令 -> 机器指令）**





## 2.字节码文件详解



### 2.1 Java虚拟机的组成

![image-20241005155325591](../../../../AppData/Roaming/Typora/typora-user-images/image-20241005155325591.png)

![image-20241005155345443](../../../../AppData/Roaming/Typora/typora-user-images/image-20241005155345443.png)

### 2.2 字节码文件的组成

#### 2.2.1 基本信息

![image-20241005155851882](../../../../AppData/Roaming/Typora/typora-user-images/image-20241005155851882.png)

magic魔术，用来检验是否是 .class文件

#### 2.2.2 常量池

就是符号表，存着要用的符号引用，主要是为 方法服务

#### 2.2.3 字段

就是类的属性信息

#### 2.2.4 方法

方法才是关键

存着方法的jvm指令

如果方法要调用别的类的方法，就通过符号引用（存在常量池）

### 2.3 类的生命周期

加载（装入） -> 连接（链接） -> 初始化（类的初始化，比如静态变量和 代码） -> 使用 -> 卸载

![image-20241005160926103](../../../../AppData/Roaming/Typora/typora-user-images/image-20241005160926103.png)





### 2.4 类加载器 (装入 和 链接)



### 2.5 双亲委派机制 （唯一 & 安全）

**向上委派，向下查找 ，是递归的** （loadClass & findClass）

保证了 唯一 & 安全，

给一个类加载器，加载类时，先问问 父类有没有加载过（递归的），如果没有，就自己加载

所以给一个 类加载器，它只能在自己和父类中加载，否则就不能加载

一个类，是由 类 & 类加载器唯一确定的





### 2.6 打破双亲委派机制



### 2.7 JDK9之后的类加载器







## 3.运行时数据区



## 4.垃圾回收

