

## 变量

它是弱对象

1. var a int = 1
2. var a := 2
3. var a int     a = 2
4. a := 1 //这个常用

var 就是 c++ 中的 auto 它会自动推导

但是呢 不要

{

var a int;

if (true) {

a := 1 // 这样a和外面的a不是同一个

}

}



## defer

它是压栈的，后进先出

return之后的语句先执⾏，defer后的语句后执⾏

**它是return之后的，而不是{} 结束的，它不是RAII但是很像**



它是函数 return时，执行的。但是return 的value，还是可以让defer改变的

因为defer的特性，RAII, 对于 网络连接，文件，锁。

都可以用defer，但是defer要是函数执行完 or panic才可以执行。

so我们 可以在开启资源后立即 defer。

但是对于锁来说，临界区应该尽可能小。so，我们可以将临界区封装成函数，then 临界区结束就会释放资源。



## 面向对象



### 封装

看属性名

首字母大写其他包可用（public）

小写 本包可用（private）

我们可以用 public方法来调用 private



#### 类的方法



要 （c * ClassName）

类中的属性，使用一定要用 c.



### 继承



1. 不是接口，类属性中有父类
2. 接口，实现它all的接口函数就可以



### 多态

还是和c++ 和 java一样

父类（接口）的指针 指向子类的对象



### 对象的建立

 object  := &{

 a: A,

b: B,

c: C, // 它最后是有逗号的

}

也可以 自己创建构造函数

```go
func NewObject(args …intereface{}) *Object {

​	return  &Object{



}

}
```





## goroutine

直接用 go 语句就可以

它就会异步执行，而不会 创建新的函数

go func()

它快是因为用户级别的，不用进入内核态，上下文切换的开销比较小

对于 CPU密集型，可以用 协程池来优化

那任务队列呢？用 chan，所以 只要给chan任务就可以了。但是给任务的 协程，和 从chan拿任务的协程是有共享资源的

**但是不要紧，chan是并发安全的，如果要减少竞争状态，可以让每个协程拥有自己的 chan**

拿竞态就  从全局chan，变成生产者 和 单个消费者



## channel

**它就是协程间通信的管道**

通过它可以实现同步

如果协程间要通信，可以使用 channel来共享内存

**chan** 就是用来解**决协程通信**

思想： 通信来共享资源，而不是共享资源来通信

而且可以成为 **任务队列**（异步，解耦（生产者与消费者））

**消息队列** 和 任务队列很像 （解耦，异步，可靠性（确认 & 超时重传），延时 ； 

but 缺点： 幂等性（唯一标识），延迟性（网络IO，网络就用 连接池（减少创建和销毁开销），顺序性（单消费者（一个key）+ hash 

（hash是为了并发，相同的hash 给同一个消费者）））



## select



功能： **一个go 监听多个 chan**。（如果是循环监听可以实现 IO多路复用；如果监听 time.After(), 可以实现超时）

如果是for 循环监听，就是减少 go程的创建



```go
func F() {
    select {
        // c1 和 c2同时好了，就随机选一个
        case: <- c1
        case: <- c2
        case: <- time.After(Time.Duration) // 如果过了指定时间还没好，就触发这个，完成超时的监听
    }
}
```

一般go协程 只能监听一个channel

有了select，他就可以监听多个channel

它和epoll很像

有了它可以实现io多路复用

但是也可以只用一个channel就可以

比如

连接建立好后

直接调用一个协程

Handler

里面执行一个死循环，调用read函数（它阻塞时，线程不会阻塞，会执行其他的协程）

有read后再调用read的回调函数

它比epoll好用的多

因为它不会阻塞线程



## make

它用来new 资源

map 

chan

slice （就是动态数组）

只有这三个是引用类型，直接传值就可以



## for

它是没有（）的

for {

}

or

for i := 1; i < 10; ++i {

}

or 

for  flag != false {

}

它的for直接取代了while（虽然for就是可以取代while）



## 函数



func 关键字

而且 func也可以定义匿名函数 就是lamada函数

如果 func 作为 变量，参数，return值，go编译器 就会为它生成 funcValue，为了能够**bind上下文**

就和c++ 的bind函数一样

而 闭包，就是 函数 + 上下文

funcValue 访问了 栈中的局部变量，那这个变量就会 逃逸到堆上，funcValue就拥有它的指针。如果这个局部变量 会变，要小心了。

因为会影响funcValue（因为存的是指针），但是可以解决 

1. 让它不变化

```go
func F() {
    for i := range 4 {
        tmp := i
        f := func() {
           // return i++ // 不好，因为i 是循环变量，会改变，但是可以用 tmp := i ; return tmp++
            return tmp
        }
    }
}
```

 

	2. 将变化的值，当作参数传入(但是如果 interface接口是固定的，就不可以用，但是可以用上面的)

```go
func F() {
    for i := range 4 {
        f := func(num int) {
            return num++
        }
    }
}
```



### 返回值

可以有多个

这些 return 都是存储在栈上的

一次函数调用时，就会在栈上生成一个栈帧

但是为什么函数的数据要存储的地方是栈呢

**因为 函数调用 是 深度遍历的，后进先出的，so 存储结构是栈**

内存回收 非常方便，移动一下指针就可以了，但是栈上存储的数据就没有了。

那不随着函数调用解决而 消亡的变量，就存储在堆上

so 堆、栈都是用来存数据的

但是堆上的数据怎么回收呢 （可达性分析，引用计数不行（循环引用））



### 匿名

func f1() int {

return 1

}



func f1() (int, string) {

return 1,2

}



### 有名

func f1() r int {

r = 1

return // 不用return数值了

}





## sync

同步包

**同步**

前后关系

对于协程通信 （chan or WaitGroup， chan是有数据交互的，WaitGroup是只要知道执行完就可以（不用数据交互，但如果要数据交互，也可以，就是要而外使用 map or chan） ）

协程通信就是 同步，就是有先后关系



**互斥**

**多线程访问了 共享资源**

比如 全局map，数据库，redis这些都要锁的

redis因为是全局的，可以提供分布式锁。



怎么减少竞态：

1. cas （将临界区的操作原子化，比如lua ，mysql，但是这种的比较少）
2. 分段锁（比如访问 全局map，可以将key mod hash，这样只会有相同hash值的会 互斥）
3. 轻量级锁 （java的，不用进入内核态）
4. 将资源线程私有化（go中协程队列就是 线程私有的，muduo 中网络连接也是 线程私有的 & 任务队列）
5. copy On write （因为读没有并发问题，如果要修改，就直接拷贝一个新的（其实也是资源私有化））



