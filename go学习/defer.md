# defer

和析构函数一样

会在函数执行结束后调用

可以用来回收系统资源（比如文件）



# 协程

go funcName（args）

它就会执行

它多线程一样，可以用来异步执行

但是它不会创建新线程

**它可以单线程并发**

**它使用阻塞操作时，不会进行线程切换**

**而是通过调度器来切换到别的协程**

我们看到，如果它是计算密集型，其实效率不会高

如果是io密集型，就非常有效



它让用户态来调度协程



## G

就是协程，它会把一个func，封装成一个协程

它会由调度器来交给一个线程执行



## M

线程，真实用来执行协程的



## P

它装着G

每个P只属于一个M

这样就不会有线程间的竞态（muduo和netty都是这个思想）

**线程池（为了可以使用多核） + 任务调度器**



# channel

它是用来协程间的同步（本质就是协程间的通信）

底层应该是用条件变量

它可以有容量，很像任务队列



# GC

垃圾回收

它使用的是标记 + 清除



## 标记清除

标记： 使用可达性分析

清除： 它不会进行内存的移动，可能会有内存碎片，但是它可以和工作线程并发执行

​			而且效率很高，因为不会进行内存的移动，它的响应时间很快





## 读写屏障

![image-20240530153031036](../../../AppData/Roaming/Typora/typora-user-images/image-20240530153031036.png)





**它可以防止还在被引用的数据被删除**

使用的是写屏障



如果是多线程，如果不stw，可能所有的线程它不知道垃圾回收开始了（通知应该就是改标记位）

**所以在垃圾回收开启前，有一段STW，通知all线程垃圾回收开始了**



**读屏障是因为在标记复制和标记清除算法指针的地址变了，不能再读旧的地址了**



```java
// Java中的一个写屏障例子
volatile int x = 0;
int y = 1;

// 写屏障保证x = 1在y = 2之前完成
x = 1;
Unsafe.getUnsafe().storeFence();  // 写屏障
y = 2;



// Java中的一个读屏障例子
volatile int x = 0;
int y = 1;

// 读屏障保证x的读取在y的读取之前完成
x = 1;
Unsafe.getUnsafe().loadFence();  // 读屏障
y = 2;

```



## 增量式回收

增量式垃圾回收是指用户程序与垃圾回收交替执行，将垃圾回收工作分多次完成，也将暂停的时间分摊到多次，进而缩短每次暂停的时间。


