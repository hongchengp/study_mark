# 消息队列

![image-20240911104027948](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911104027948.png)

![image-20240911104211749](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911104211749.png)

![image-20240911104357321](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911104357321.png)

## publisher

消息的发送者

它会指定发送给的交换机和routingkey

交换机根据routingkey来发送给MQ（routingkey == bindingkey）



## 交换机

具有路由功能

**迪米特法则，增加中间层，让publisher和MQ解耦**

如果pulisher要再给别的MQ不用改变原有代码，还是给交换机

只用改变交换机就可以

它接受publisher发送的消息（routingkey）

它和队列绑定bindingkey（当routingkey == bindingkey时，发送给该队列）

![image-20240911104447703](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911104447703.png)

![image-20240911104517554](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911104517554.png)

![image-20240911104702118](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911104702118.png)

![image-20240911105035915](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911105035915.png)



![image-20240911105313884](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911105313884.png)

![image-20240911105330185](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911105330185.png)

## MQ

它和交换机绑定（bindingkey）

它也会和消费者绑定但是不用key，直接给绑定它的队列就可以（每条消息只会给一个消费者，防止重复消费，虽然还是会重复消费）

![image-20240911163825606](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911163825606.png)

![image-20240911164436275](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911164436275.png)



## 消费者

它和MQ绑定，用TCP进行可靠连接

消费消息

消费者和MQ也可以变成publisher

比如死信队列，error队列



### Fanout

广播





### Direct

路由



### Topic

也是路由

但是可以用通配符





## spring 集成 mq



**交换机**

![image-20240911143037645](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911143037645.png)

**队列**

![image-20240911143116181](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911143116181.png)

![image-20240911143327890](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911143327890.png)

![image-20240911143552550](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911143552550.png)

![image-20240911143718311](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911143718311.png)

![image-20240911143759856](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911143759856.png)

 

**注解开发的**

![image-20240911144028652](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911144028652.png)

![image-20240911144217599](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911144217599.png)



### 消息转换

和redisTemplate一样

都是用的jdk的序列化与反序列化

非常占用空间

![image-20240911144353151](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911144353151.png)



不好用，就用别的

怎么引入

1. maven坐标
2. 配置文件（如果需要，比如mysql的IP port，用户，密码）
3. 如果是starter 可以直接使用template（因为它自动配置了 ，就是@Configuration & @Bean）
4. @Configuration + @Bean 注入到spring容器（@Configuration，就是代替配置类）



#### 自定义json转换

![image-20240911145022536](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911145022536.png)

![image-20240911145318655](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911145318655.png)

#### 消费者接收

它发的是什么类型，接受也是什么类型

![image-20240911145513079](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911145513079.png)



### 入门程序

#### 配置

![image-20240911145822334](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911145822334.png)

![image-20240911145848312](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911145848312.png)

#### consumer

![image-20240911150211388](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911150211388.png)



#### publisher

![image-20240911150425147](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911150425147.png)



## 可靠性



#### publisher 可靠

##### 重试

![image-20240911153749829](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911153749829.png)

![image-20240911153706124](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911153706124.png)

#### 生产者确认机制

确保方法正确的到达 exchange （和tcp很像，应该是 超时重传 & 确认ack）

![image-20240911154034330](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911154034330.png)

![image-20240911154209389](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911154209389.png)



#### 实现生产者确认

![image-20240911154355773](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911154355773.png)

**回调函数设置（@Configuration + rabbitTemplate）**

![image-20240911154610606](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911154610606.png)



**confirmCallback (nack执行的回调函数)**

信息的格式不尽相同，so 回调函数也不一样

so 在发送消息时，**就要指定callback**，**还要知道是 那条消息，所以也要消息的 唯一id**

![image-20240911155140692](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911155140692.png)

![image-20240911155242854](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911155242854.png)

![image-20240911155336876](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911155336876.png)

![image-20240911155504866](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911155504866.png)



回调函数publisher调用的，但是要ack or nack到达才会调用，这要时间的

so 用future，异步调用

rabbitmq 回执（就是发送 ack or nack），只会发送id，那id哪里来

![image-20240911162015728](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162015728.png)

publisher通过 id 找到 相应的回调函数

![image-20240911162159998](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162159998.png)



#### MQ的可靠性

![image-20240911163531833](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911163531833.png)



#### 数据持久化

![image-20240911162349093](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162349093.png)

![image-20240911162428912](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162428912.png)

#### LazyQueue

![image-20240911162538527](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162538527.png)

**它是存在内存，快，但是如果内存满了，就要持久化，会阻塞，寄**

**不如一开始就持久化到内存**

![image-20240911162713395](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162713395.png)

![image-20240911162749631](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162749631.png)

![image-20240911162835825](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162835825.png)

![image-20240911162858675](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911162858675.png)

![image-20240911163053718](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911163053718.png)

![image-20240911163214653](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911163214653.png)



### 消费者可靠性

#### 消费者确认机制

和tcp一样，但和生产者确认不同，它是消费者 return  ack or nack，mq重新发送

![image-20240911165543107](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911165543107.png)

![image-20240911165636625](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911165636625.png)



#### 失败重试机制

![image-20240911165747983](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911165747983.png)

![image-20240911165830702](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911165830702.png)

![image-20240911165854014](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911165854014.png)



#### 失败处理策略

![image-20240911165957722](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911165957722.png)

![image-20240911170024709](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911170024709.png)

![image-20240911170313270](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911170313270.png)



## 幂等性

#### 唯一id

对于每条消息，定义唯一id

消费了它，就存入 数据库

每次业务代码，都会先查询是否有id

有，就不调用（这个是很多方法都会调用的，so可以用aop环绕通知）

但是它很多，不好用redis存，应该用什么呢

![image-20240911180757514](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911180757514.png)



#### 业务判断

![image-20240911181344812](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911181344812.png)



### 可靠性兜底

如果MQ生产者，MQ，消费者可靠机制还是寄了

就是说 生产者 给 消费者 的信息还是寄了（没有到）

那消费者就主动的去 pull（拉取，和github一样）





### 延时消息



#### 死信队列

![image-20240911192046829](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911192046829.png)

![image-20240911192108961](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911192108961.png)



#### 延时交换机

![image-20240911192219082](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911192219082.png)

![image-20240911192259819](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911192259819.png)

![image-20240911192430730](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911192430730.png)

![image-20240911192653994](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240911192653994.png)



就是说，消息给了延时交换机，就会到了时间再给queue，queue再给 消费者



#### 实现

定时任务很花时间

一般来说 订单下了，会在较短的时间支付

so，我们可以让延时时间，依次变长

就是给消息体，定义一个 Time数组，递增的，代表每次delay的time

只有没有了（就是时间到了最长了），才取消订单





## 解决问题



### 系统解耦

让生产者 直接调用MQ的发送消息即可（这个基本是不会变的，它是面向抽象的，就是接口（不变的））

让消费者 与 消费者解耦了

**不同模块间，应该尽可能的低耦合，尽可能不了解其他模块细节** 

而且 有了exchange，就可以非常方便的扩展功能，让exchange 在bind 新的 queue，then queue给新的消费者就可以

而且不会**联级失败**



### 异步

如果操作没有同步关系，那他们就可以并发执行（异步）

和异步io一样，可以提高响应速度



### 数据一致性

依靠的MQ的可靠性（生产者（确认机制），MQ（持久化，lazy思想），消费者（确认机制 & error队列））

binlog -> canal -> mq -> redis



确认是对消息的确认，怎么知道是那个消息的，用唯一id



## 引入问题



### 可靠性

生产者 确认机制

MQ 持久化 lazy队列

消费者 确认机制 & error（保底，人工处理）



### 幂等性

1. 用锁，在上锁期间，相同的消息是不能消费的（但是只有上锁的时间不会，只是一段时间的幂等）
2. 唯一id （来时，用lua（为了原子性），if 有 then 寄 else 加入 消费）和锁一样，如果有ttl，如果没有ttl，那就会存太多
3. 业务逻辑，对于select它是天然幂等



### 顺序消费

**消息队列是fifo的，而且消息发送是顺序的（逻辑时钟）**

**A -> B -> C 的顺序，如果ABC是不同的消费者处理，那会有并发问题，不能顺序处理**

**但是如果单线程处理，那就可以保证顺序，但是效率非常低**

**then 可以用分片的思想，用 hash + mod，同一个hash的，是同一个消费者，也可以保证顺序性**

也是并发的

并发 可以多个 消费但是带来了 并发问题（任何事务都是有代价的）



### 延迟

因为有网络io，**可以用批处理**（减少io次数），也可以用连接池（减少连接 创造 销毁的开销）

也可以增加 消费者数量



# Redis



## 高级篇

**底层数据结构，就是说，string、list、set、hash、zset都是由这些实现的**

### 1.1redis底层数据结构-SDS（simple 动态 string）

它是二进制安全的(因为记录长度，不会遇到‘/0’就结束)

动态扩容



### 1.2redis底层数据结构-intset

底层是数组（元素的长度一致，ziplist是不一致）



### 1.3redis底层数据结构dict （字典）

![image-20240910210550579](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910210550579.png)

![image-20240910210525854](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910210525854.png)

![image-20240910210816955](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910210816955.png)

![image-20240910210831601](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910210831601.png)

#### dict扩容

如果(entrySize/dictSize  >= 1 && 没有子进程任务 ) || (entrySize/dictSize >= 5) 进行扩容

因为hash冲突多了（就是id % mod），扩容大小 会找第一个 大于 size的2**n

扩容时ht[1] 就是新的dict（分配内存），但是如果一次性rehash，工程量太大

使用lazy操作，访问到dict时，顺便rehash

那增删改查怎么办，两个都找啊

反正O(1) 复杂度



#### 小总结

Dict的结构：

* 类似java的HashTable，底层是数组加链表来解决哈希冲突
* Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash

Dict的伸缩：

* 当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容
* 当LoadFactor小于0.1时，Dict收缩
* 扩容大小为第一个大于等于used + 1的2^n
* 收缩大小为第一个大于等于used 的2^n
* Dict采用渐进式rehash，每次访问Dict时执行一次rehash
* rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表



### 1.4 redis底层结构-ziplist

![image-20240910211726460](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910211726460.png)

​	![image-20240910212247874](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910212247874.png)



#### 连锁更新

如果修改元素后，它的长度超过了254字节，而它的后继节点是一大片的250-253字节长度，就会导致很多entry改变

so 它不适合大量数据存储（修改查找代价太大）

![image-20240910212658466](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910212658466.png)



#### **小总结**

**ZipList特性：**

* 压缩列表的可以看做一种连续内存空间的"双向链表"
* 列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低
* 如果列表数据过多，导致链表过长，可能影响查询性能
* 增或删较大数据时有可能发生连续更新问题



### 1.5redis底层数据结构-quickLIst

![image-20240910212757086](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910212757086.png)

是双向链表



#### 总结

QuickList的特点：

* 是一个节点为ZipList的双端链表
* 节点采用ZipList，解决了传统链表的内存占用问题
* 控制了ZipList大小，解决连续内存空间申请效率问题
* 中间节点可以压缩，进一步节省了内存



### 1.6redis底层数据结构-skipList

跳表，对于链表的二分查找要找到中间节点要O(N)

如果记录了中间节点就好了（跳表）

![image-20240910213134293](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910213134293.png)

**特性**

有序的

通过多级指针，快速找到中间位置

![image-20240910213314757](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910213314757.png)

、

#### 小总结

SkipList的特点：

* 跳跃表是一个双向链表，每个节点都包含score和ele值
* 节点按照score值排序，score值一样则按照ele字典排序
* 每个节点都可以包含多层指针，层数是1到32之间的随机数
* 不同层指针到下一个节点的跨度不同，层级越高，跨度越大
* 增删改查效率与红黑树基本一致，实现却更简单



### 1.7 redis数据结构-redisObject

它封装了value（就是我们用到的string，set，hash等）

用type表明是说明类型

![image-20240910214054463](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910214054463.png)

### 1.8redis数据结构-string



![image-20240910214308260](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910214308260.png)

你看可以通过encoding来看他是不是number，快速的加减



### 1.9redis数据结构-list

它是有序的

底层：

linkedlist

ziplist

quicklist

后面都用quicklist了

linkedlist太内存开销太大

ziplist使用连续内存，不好申请，而且修改开销很大

quicklist就是ziplist数组，用到了ziplist的节省内存，而且ziplist不用太大，不会用到太大的连续内存



### 1.10 redis数据结构-Set

他要不重复

可以用dict，key就是key，value为null（不会多申请空间），但是还是浪费空间了

小就用 intset



### 1.11 redis数据结构-Zset

用skipList or dict



### 1.12 redis数据结构-Hash

就用dict or ziplist（数据少时）



## 网络模型



### 内核态与用户态

系统调用，是内核暴露给用户的接口

但是这些指令要在内核态才能使用

那就要切换上下文（寄存器等等），很费时间，但是安全

![image-20240910220013666](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240910220013666.png)

我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而简介的实现对内核的操控，但是内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，因此我们需要把用户和**内核隔离开**

进程的寻址空间划分成两部分：**内核空间、用户空间**







## redis & mysql一致性

我们都知道，如果一个业务，有多条写sql，会引发一致性问题（用事务解决）

那如果，在delete or update数据时，要删除redis记录怎么办啊，如果redis没执行成功，也会不一致（最终一致性）

用事务，开销太高了。so怎么办呢，本质是不一定redis删除成功

欸嘿 ，消息队列

但是如果用消息队列，代码侵入性太强了

用 binlog & MQ

![image-20240928194251516](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20240928194251516.png)

这是what，就是对于写操作，会有binlog记录。

我们让consumer订阅 binlog就好了，让它发给 MQ，之后有人去删除redis数据



### 什么时候删除redis

在数据更改时



### 什么时候添加redis

在查找数据时（redis 就是为了减少读开销的，so有读，一定要小心啊）

在新增数据时（这个不一定，新增加，是数据预热）



### 布隆过滤

它是一个快速 & 低开销的，查找有没有记录的数据结构

底层是 hash，用很多位来判断它在不在，但是会有误判，

有不一定有，but无，一定无



### 删除数据how do

我们可以再开一个redis，来记录删除的数据

```c 
if (!bloom.has(key)) return;
if (isNull(key)) return;
// 查数据库
if (DB.isNULL(key)) {
	isNULL.set(key); // 缓存穿透更加保险了
}
```



### 锁

一般什么时候用锁呢

if (read) {

write();

}

在又有读 & 写的时候，要**先判断后写**，因为不是原子的



那写写是不是更应该，是的。但是if 它们底层是 cas的感觉可以不用（cas 底层会锁住内存，只有一个线程可以访问，而且不会引发线程切换）

那是不是 要先判断后读都要加锁呢，不一定，why

because，有cas，or 实现的原子的先判断后写方法，比如 PutIfAbsent(); 还有数据库的，if 没有插入 else insert（是原子的，不用上锁）





用setnx

#### 重入

存机器id & thread

& 存引用计数



#### 超时释放

防止死锁

用ttl



#### 误删

用lua脚本（因为有判断 & 写，所以有并发问题）

lua脚本，看是不是自己的，是就删除





## 常见问题



### bigKey

就是一个key存的内容太多

比如hash，set，string

**IO负担非常大**

**内存负担**

**操作慢**



#### ttl

用过期，防止存的太多



#### 分片



#### 垂直分片

想好key的结构

一个key不要存太多



#### 水平分片

和分表分库一样，用hashmod，一个key可以存在多个节点，防止一个key太多



#### bitmap

用位来存，和bloomFilter （布隆过滤器，一个二进制就可以存）



### 持久化



#### rdb

**将所有的数据用二进制存在磁盘**

**应该用异步io**

但是数据量很大，不能高频率的生成rdb

两次rdb之间发生故障，就会丢失较多的数据

但是二进制，恢复很快，只用复制就可以



#### aof

逻辑日志

每次写操作，将操作写入aof

（但是如果每次写，都直接写入磁盘，io开销非常大 用 异步io & 批处理解决）

aop写入磁盘，间隔很小

so数据丢失风险小

但是，aop文件很大 & 恢复时开销很大，因为要一个一个进行写操作



#### 选那个

![image-20241014153024848](../../../鲸云雾起/AppData/Roaming/Typora/typora-user-images/image-20241014153024848.png)



### 淘汰策略

和cache一样

要利用好局部性原理

lru我觉得就很好



#### ttl

用的lazy（查到你&ttl过期了，就删除）

 & 定期任务





## 典型应用



### 分布式锁

锁一般的底层原理是 cas（锁住内存，多个竞争只有一个能成功）

redis不是，因为它是单线程的，不会有原子问题

用setnx & lua（单独操作原子，但是多个组合不是原子）



### 缓存

一般使用 对mysql的读，因为mysql不能一次处理太多请求，否则就会直接寄

写完，就删除redis



### 限流

为什么用限流呢，防止太多的请求让服务请崩溃

（联级失败，服务雪崩（就是一种请求，将线程池占用完了，让依赖他的请求 & 其他请求烂了，then 递归这个操作））



#### 漏桶

就是处理的速度是一致的

容量恒定，多个就丢弃

它是先进先出，可以用redis的list 来实现



#### 令牌桶

容量恒定，周期性的加入令牌，只有得到令牌才可以处理

可以用 redis的hash处理，但是用定时任务不好

可以用lazy操作 & 时间戳（if time 在规定时间，then 可以加令牌）

当然都要用lua脚本（脚本就是不用编译的一系列指令）

**它可以应对一定量的容量波动**



#### 滑动窗口

在一定时间段内，只能处理一定数量的请求

比如 1分钟内处理 100个请求

可以用 **redis 的 zset & 时间戳**，如果它前面规定时间内没有超过，then 可以处理（也要ttl，不能有bigkey）



